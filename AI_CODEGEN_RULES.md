## AI 代码生成规则（高可读性/可维护性）

目标：当使用 AI 生成或重构代码时，统一遵循以下工程化规则，确保代码清晰、可靠、易演进。

---

### 一、核心工程原则

- **SOLID**：
  - 单一职责：每个模块/类/函数只做一件事；文件职责明确。
  - 开闭原则：对扩展开放，对修改封闭；倾向于通过新增实现/策略替代修改既有逻辑。
  - 里氏替换：子类型可无缝替换父类型；对外合同不被破坏。
  - 接口隔离：面向精小接口；避免胖接口；调用方只依赖所需能力。
  - 依赖反转：高层依赖抽象而非具体；通过注入解耦实现。

- **DRY**（不要重复自己）：
  - 拒绝复制粘贴式实现；抽取公共逻辑为可复用单元（函数/模块/库）。
  - 共享数据结构/类型定义，避免影子结构与隐式耦合。

- **KISS**（保持简单）：
  - 选择最简单可工作的设计；避免过度抽象与提前优化。
  - 控制嵌套层级 ≤ 2-3；优先早返回而非深层 if-else。

- **YAGNI**（你不会需要它）：
  - 不实现未被当前需求驱动的“潜在”功能；以演进式扩展替代一次性完美化。

- **单一抽象层级**：
  - 同一函数内保持一致的抽象层次；高层不夹杂底层细节。

---

### 二、架构与模块化

- 分层清晰：接口/领域/基础设施分离；边界明确（输入输出、错误模型、契约）。
- 纯函数优先：有副作用的逻辑与纯计算拆分，便于测试与复用。
- 依赖注入：外部资源（DB、HTTP、配置）通过构造注入或工厂提供；便于替换与测试。
- 配置外置：使用环境变量或配置文件，避免硬编码。

---

### 三、命名与可读性

- 语义化、完整单词，不用随意缩写；名称传达“意图”而非实现细节。
- 函数名用动词/动宾（如 `loadUserProfile`），变量名用名词短语（如 `userProfile`）。
- 魔法数字/字符串一律提取为常量并加语义化命名。

---

### 四、函数/类设计规范

- 函数长度与职责：小而专一；超过 ~40-60 行需考虑拆分。
- 参数数量 ≤ 3；超过时用对象参数/配置结构体承载。
- 明确返回类型；避免隐式返回与混合返回风格。
- 失败优先与早返回；尽量减少嵌套。

---

### 五、错误处理与日志

- 不吞错：捕获后要么语义化上抛，要么就地转化为可理解的业务错误。
- 错误模型一致：自定义错误类型/枚举（或错误码/原因），包含上下文信息。
- 日志分级（debug/info/warn/error），日志面向定位问题而非堆栈刷屏。
- 对外信息最小化：避免泄露敏感实现细节或隐私数据。

---

### 六、测试策略

- 单元测试覆盖核心纯逻辑与关键分支；集成测试覆盖跨模块/外部资源交互。
- 对回归风险高的缺陷补回测；对并发/边界条件补强测试。
- Mock 外部依赖；断言行为与契约而非实现细节。

---

### 七、文档与注释

- 注释写“为什么”，代码体现“如何做”。避免赘述显而易见的实现。
- 公共 API/导出函数需有简明注释与使用示例/契约说明。
- 更新/新增重要能力时，同步更新 README/架构说明与迁移指引。

---

### 八、安全与合规

- 输入校验与类型约束到位；杜绝 `eval`、拼接式 SQL/命令注入。
- 严禁在代码库存储密钥/凭证；使用密钥管理/环境变量。
- 外部调用设定超时/重试/熔断；避免 SSRF/任意文件访问等风险。

---

### 九、性能与可扩展性

- 基于度量进行优化；先设基线，再定位瓶颈。
- 时间/空间复杂度可解释；对大数据量使用流式/增量处理。
- 合理缓存并设计失效策略；避免缓存不一致。

---

### 十、风格与工具

- 统一格式化与静态检查（示例：ESLint/Prettier、mypy/ruff、golangci-lint）。
- 代码提交遵循 Conventional Commits（如 `feat: ...` / `fix: ...`）。
- PR 小步可审查：自包含、原子化、通过所有检查与测试。

---

### 十一、拉取请求检查清单（提交前自检）

1. 命名语义化、函数职责单一、无魔法常量。
2. 公共接口/导出项均有注释或示例；README/文档同步更新。
3. 无重复代码；公共逻辑已抽取复用。
4. 错误处理一致，日志清晰且不泄露敏感信息。
5. 新增/变更点已覆盖必要测试，且本地通过。
6. 通过格式化与静态检查，无告警或已有充分理由。
7. 性能/安全边界已评估，必要时有基准或说明。

---

### 十二、语言附则

- TypeScript / JavaScript：
  - `strict` 模式；避免 `any`；优先类型别名/接口与判别联合建模领域。
  - 返回 Promise 场景统一 `async/await`；边界处集中处理错误。
  - 模块按领域组织；导出最小化；公共类型置于 `types.ts`。

- Python：
  - 全量类型标注与 `pyproject.toml` 管理工具链；开启静态检查（mypy/ruff）。
  - I/O 使用上下文管理器；明确异常边界；数据校验可用 `pydantic`。
  - 包内 `__init__.py` 控制导出面；保留清晰的包结构与层次。

- Go：
  - 接口小而专；以行为命名；面向接口编程；传递 `context.Context`。
  - 错误使用 `errors.Is/As` 进行判定；避免忽略返回错误。
  - 包划分按领域；避免循环依赖；导出最小化。

---

### 十三、禁止事项（强约束）

- 超长函数/文件、深层嵌套、复制粘贴式复用、注释掉的大段代码。
- 全局可变状态（除非有严格保护与必要性说明）。
- 静默吞错或仅打印不处理；隐式改变外部可见行为。
- 未经校验的外部输入直达核心逻辑或持久层。

---

### 十四、最小模板（示例）

TypeScript 函数模板：

```ts
// 说明：动宾命名、明确参数与返回类型、早返回、错误上抛
export interface LoadUserOptions {
  readonly includePosts?: boolean;
}

export async function loadUserProfile(userId: string, options: LoadUserOptions = {}): Promise<UserProfile> {
  if (!userId) {
    throw new Error("userId is required");
  }
  const profile = await userRepository.findById(userId);
  if (!profile) {
    throw new Error("user not found");
  }
  return options.includePosts ? enrichWithPosts(profile) : profile;
}
```

Python 函数模板：

```python
from typing import Optional

def load_user_profile(user_id: str, include_posts: bool = False) -> dict:
    if not user_id:
        raise ValueError("user_id is required")
    profile = repository.find_by_id(user_id)
    if profile is None:
        raise LookupError("user not found")
    return enrich_with_posts(profile) if include_posts else profile
```

---

实施说明：

- 当由 AI 生成新代码或重构既有代码时，应默认遵循本规则；如需例外，应在 PR 中简要说明理由与权衡。
- 后续可根据团队反馈持续演进本规则，并保持向后兼容的基本约束不变。
